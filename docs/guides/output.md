# Output Formatting Guide

# Output Formatting Guide

This guide explains how to customize the **console output** of test results in Firmo and clarifies the role of the `--format` flag for **report file generation**.

## Introduction

When running tests, clear and readable output is essential for quickly understanding results. Firmo provides ways to customize how test results are displayed in the console and how structured report files are generated.

-   **Console Output:** Controlled primarily through **programmatic configuration** (`firmo.format({})`). Offers options for colors, indentation, verbosity levels, and basic styles (detailed, dot mode).
-   **Report Files:** Generated by the reporting system. The **type** of report file (e.g., HTML, JUnit, JSON) is specified using the `--format` **command-line flag**.

This guide focuses mainly on configuring the **console output**. See the [Reporting Guide](./reporting.md) for details on generating report files.

## Console Output Formatting

### Programmatic Formatting (`firmo.format`)

You can also configure output programmatically:

```lua
local firmo = require("firmo")
-- Configure output style
firmo.format({
  use_color = true,      -- Use colored output
  indent_char = '  ',    -- Use spaces for indentation
  indent_size = 2,       -- Two spaces per level
  show_trace = true,     -- Show stack traces for errors
  compact = false        -- Use verbose output
})
```

## Customizing Output Appearance

### Color Configuration

Colors help highlight important information:

```lua
-- Enable colors (default)
firmo.format({ use_color = true })
-- Disable colors (for terminals without ANSI support)
firmo.format({ use_color = false })
-- Shorthand to disable colors
firmo.nocolor()
```

### Indentation Settings

Control how nested tests are indented:

```lua
-- Use two spaces per level
firmo.format({
  indent_char = ' ',
  indent_size = 2
})
-- Use tabs (default)
firmo.format({
  indent_char = '\t',
  indent_size = 1
})
```

### Error Reporting

Configure how much detail is shown for errors:

```lua
-- Show stack traces for errors
firmo.format({ show_trace = true })
-- Hide stack traces for concise output
firmo.format({ show_trace = false })
```

### Success Details

Control whether passing tests show details:

```lua
-- Show details for passing tests (default)
firmo.format({ show_success_detail = true })
-- Hide details for passing tests
firmo.format({ show_success_detail = false })
```

## Advanced Output Options

### Environment-based Configuration

Adapt output based on the execution environment:

```lua
-- Configure output based on environment
if os.getenv("CI") then
  -- CI environment - use plain output for logs
  firmo.format({
    use_color = false,
    summary_only = true
  })
elseif os.getenv("DEBUG") then
  -- Debug mode - show all details
  firmo.format({
    use_color = true,
    show_trace = true,
    show_success_detail = true
  })
else
  -- Normal development - balanced output
  firmo.format({
    use_color = true,
    compact = false,
    show_trace = false
  })
end
```

### Custom Formatters

For specialized output needs, consider using **report file** formatters (configured via the reporting module and triggered by `--format`):

```lua
-- Configure HTML formatter using central_config
local central_config = require("lib.core.central_config")
local reporting = require("lib.reporting")
-- Configure HTML formatter
reporting.configure_formatter("html", {
  theme = "dark",               -- Use dark theme
  show_line_numbers = true,     -- Show line numbers
  collapsible_sections = true,  -- Allow collapsing sections
  highlight_syntax = true       -- Enable syntax highlighting
})
-- Run tests, generating an HTML file report (does not change console output)
-- lua firmo.lua --format=html tests/
```

### Report File Generation

Generate structured report files using the `--format` command-line flag. The output path is typically configured via `central_config` or reporting module settings, not via `--output-file`.

```bash
# Generate an HTML file report (e.g., coverage-reports/coverage-report.html)
lua firmo.lua --coverage --format=html tests/

# Generate a JSON file report (e.g., coverage-reports/test-results.json)
lua firmo.lua --format=json tests/

# Generate a JUnit XML file report (e.g., coverage-reports/test-results.xml)
lua firmo.lua --format=junit tests/
```
See the [Reporting Guide](./reporting.md) for more details on available report formats and configuration.

## Common Use Cases

### Large Test Suites

For large test suites, consider using dot or compact mode for console output via programmatic configuration:

```lua
firmo.format({ dot_mode = true })
-- or
firmo.format({ compact = true })
```
Run tests as usual:
```bash
lua firmo.lua tests/
```

### Continuous Integration

For CI systems, you typically want standard console output (potentially disabling color via `NO_COLOR` environment variable if needed) and generate a structured report file like JUnit XML using `--format`:

```bash
# Run tests and generate JUnit XML report file
export NO_COLOR=1 # Optional: Disable console colors
lua firmo.lua --format=junit tests/
```
You can configure programmatic options like `summary_only` via central config if desired for CI runs.

### Debugging Tests

When debugging, use detailed output with stack traces:

```lua
-- Configure for debugging
firmo.format({
  use_color = true,
  show_trace = true,
  show_success_detail = true,
  compact = false
})
```

### Terminal Output vs. HTML Reports

Different formats serve different purposes:

```bash

# Quick feedback in terminal

lua firmo.lua --format compact tests/

# Generate comprehensive HTML report

lua firmo.lua --format html --output-file coverage-report.html tests/
```

## Best Practices

1.  **Programmatic Console Style**: Configure console output styles (dot, compact, summary, colors, indentation) programmatically using `firmo.format({})`, potentially driven by environment variables or central configuration.
2.  **CLI for Report Files**: Use the command-line `--format <type>` flag solely to specify the desired **report file format** (e.g., `junit`, `html`, `json`).
3.  **Consider Terminal Capabilities**: Be mindful that ANSI colors (`use_color = true`) may not render correctly everywhere. Rely on environment variables (`NO_COLOR`) or programmatic settings to disable color if needed.
4.  **Balance Console Verbosity**: Use programmatic options like `compact`, `dot_mode`, or `summary_only` to reduce console noise for large test suites, while keeping `show_trace = true` available for debugging.
5.  **Use Report Files for CI**: Rely on structured report files (JUnit, JSON) generated via `--format` for detailed CI analysis, rather than parsing console output.
6.  **Consistent Configuration**: Set project-wide defaults for console formatting using central configuration or a shared setup script.

## Troubleshooting Output Issues

   ```lua
   firmo.format({ use_color = true })
   ```

3. If colors can't be supported, explicitly disable them:

   ```lua
   firmo.format({ use_color = false })
   ```

### Too Much or Too Little Information

If output is hard to read:

1. For too much console output, try configuring compact or dot mode programmatically:
   ```lua
   firmo.format({ compact = true })
   -- or
   firmo.format({ dot_mode = true })
   ```

2. For too little detail on the console, ensure detailed mode is set programmatically (it's usually the default):
   ```lua
   firmo.format({ compact = false, dot_mode = false, summary_only = false })
   ```

3. For debugging errors, enable stack traces:

   ```lua
   firmo.format({ show_trace = true })
   ```
## Conclusion

Effective output formatting helps you quickly understand test results. Firmo allows customization of **console output** primarily through the programmatic `firmo.format({})` function, offering control over colors, indentation, and basic styles like dot mode. The **command-line `--format` flag** is used separately to specify the type of **report files** (like JUnit or HTML) generated by the reporting system. Understanding this distinction allows you to tailor both your interactive console feedback and your automated reporting outputs effectively.
For practical examples, see the [output examples](/examples/output_examples.md) file.
