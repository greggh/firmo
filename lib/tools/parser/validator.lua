--- AST Validator
---
--- This module implements a validator for the abstract syntax tree (AST)
--- generated by the parser. It checks for semantic errors like misplaced
--- break statements, invalid goto jumps, and misuse of varargs.
--- Based on lua-parser by Andre Murbach Maidl (https://github.com/andremm/lua-parser).
---
--- @module lib.tools.parser.validator
--- @author Andre Murbach Maidl (original), Firmo Team (adaptations)
--- @license MIT
--- @copyright 2023-2025 Firmo Team, Andre Murbach Maidl (original)
--- @version 1.0.0

---@class parser.validator The public API for the AST validator.
---@field _VERSION string Module version.
---@field validate fun(ast: table, errorinfo: {subject: string, filename: string}): table|nil, string? Validates the AST structure and semantics. Returns the validated AST table, or nil and error message.
---@field syntaxerror fun(errorinfo: {subject: string, filename: string}, pos: number, msg: string): string Helper function to format syntax error messages.

local M = {
  -- Module version
  _VERSION = "1.0.0",
}

-- Lazy-load dependencies to avoid circular dependencies
---@diagnostic disable-next-line: unused-local
local _logging

-- Local helper for safe requires without dependency on error_handler
local function try_require(module_name)
  local success, result = pcall(require, module_name)
  if not success then
    print("Warning: Failed to load module:", module_name, "Error:", result)
    return nil
  end
  return result
end

--- Get the logging module with lazy loading to avoid circular dependencies
---@return table|nil The logging module or nil if not available
local function get_logging()
  if not _logging then
    _logging = try_require("lib.tools.logging")
  end
  return _logging
end

--- Get a logger instance for this module
---@return table A logger instance (either real or stub)
local function get_logger()
  local logging = get_logging()
  if logging then
    return logging.get_logger("validator")
  end
  -- Return a stub logger if logging module isn't available
  return {
    error = function(msg)
      print("[ERROR] " .. msg)
    end,
    warn = function(msg)
      print("[WARN] " .. msg)
    end,
    info = function(msg)
      print("[INFO] " .. msg)
    end,
    debug = function(msg)
      print("[DEBUG] " .. msg)
    end,
    trace = function(msg)
      print("[TRACE] " .. msg)
    end,
  }
end

-- Utility functions for scope management
local scope_util = {}

--- Calculate line number and column from a 1-based character position in a string.
---@param subject string The source string.
---@param pos number The character position (1-based).
---@return number line Line number (1-based).
---@return number col Column number (1-based).
---@private
---@param subject string The source string.
---@param pos number The character position (1-based).
---@return number line Line number (1-based).
---@return number col Column number (1-based).
---@private
function scope_util.lineno(subject, pos)
  if pos > #subject then
    pos = #subject
  end
  local line, col = 1, 1
  for i = 1, pos do
    if subject:sub(i, i) == "\n" then
      line = line + 1
      col = 1
    else
      col = col + 1
    end
  end
  return line, col
end

--- Create a new function scope in the environment.
---@param env table Validation environment.
---@return number New function scope ID.
---@private
function scope_util.new_function(env)
  env.fscope = env.fscope + 1
  env["function"][env.fscope] = { is_vararg = false }
  return env.fscope
end

--- End the current function scope.
---@param env table Validation environment.
---@return number Previous function scope ID.
---@private
function scope_util.end_function(env)
  env.fscope = env.fscope - 1
  return env.fscope
end

--- Create a new block scope.
---@param env table Validation environment.
---@return number New scope ID.
---@private
function scope_util.new_scope(env)
  env.scope = env.scope + 1
  env.maxscope = env.scope
  env[env.scope] = { label = {}, ["goto"] = {} }
  return env.scope
end

--- End the current block scope.
---@param env table Validation environment.
---@return number Previous scope ID.
---@private
function scope_util.end_scope(env)
  env.scope = env.scope - 1
  return env.scope
end

--- Increment loop nesting counter.
---@param env table Validation environment.
---@return number New loop depth.
---@private
function scope_util.begin_loop(env)
  env.loop = env.loop + 1
  return env.loop
end

--- Decrement loop nesting counter.
---@param env table Validation environment.
---@return number Previous loop depth.
---@private
function scope_util.end_loop(env)
  env.loop = env.loop - 1
  return env.loop
end

--- Check if currently inside a loop.
---@param env table Validation environment.
---@return boolean `true` if loop depth > 0.
---@private
function scope_util.insideloop(env)
  return env.loop > 0
end

--- Formats a syntax error message including filename, line, column, and the specific error detail.
--- Also logs the error using the module's get_logger().
---@param errorinfo {subject: string, filename: string} Table containing the source string and filename.
---@param pos number The character position (1-based) where the error occurred.
---@param msg string The specific error message detail (e.g., "invalid break").
---@return string The fully formatted error message string.
---@private
local function syntaxerror(errorinfo, pos, msg)
  local l, c = scope_util.lineno(errorinfo.subject, pos)
  local error_msg = "%s:%d:%d: syntax error, %s"

  get_logger().error("Syntax error in source", {
    filename = errorinfo.filename,
    line = l,
    column = c,
    message = msg,
    position = pos,
  })

  return string.format(error_msg, errorinfo.filename, l, c, msg)
end

--- Check if a label exists in the current or outer scopes.
---@param env table Validation environment.
---@param scope number Starting scope ID to search from.
---@param stm table Label or Goto statement AST node (must have label name at index 1).
---@return boolean `true` if the label is found in a visible scope.
---@private
local function exist_label(env, scope, stm)
  local l = stm[1]
  for s = scope, 0, -1 do
    if env[s]["label"][l] then
      return true
    end
  end
  return false
end

--- Sets a label definition in the current scope. Checks for duplicates.
---@param env table Validation environment.
---@param label string The label name.
---@param pos number The position where the label is defined.
---@return boolean|nil success `true` if set successfully, `nil` if duplicate found.
---@return string? error_message Error message if duplicate found.
---@private
local function set_label(env, label, pos)
  get_logger().debug("Setting label in current scope", {
    label = label,
    scope = env.scope,
    position = pos,
  })

  local scope = env.scope
  local l = env[scope]["label"][label]

  if not l then
    env[scope]["label"][label] = { name = label, pos = pos }
    get_logger().debug("Label set successfully", {
      label = label,
      scope = scope,
    })
    return true
  else
    local line = scope_util.lineno(env.errorinfo.subject, l.pos)
    local msg = "label '%s' already defined at line %d"
    msg = string.format(msg, label, line)

    get_logger().error("Label already defined", {
      label = label,
      existing_line = line,
      new_position = pos,
    })

    return nil, syntaxerror(env.errorinfo, pos, msg)
  end
end

--- Adds a `goto` statement node to the list of pending gotos for the current scope.
--- These are verified later to ensure the target label exists.
---@param env table Validation environment.
---@param stm table The Goto statement AST node.
---@return boolean `true` (always succeeds).
---@private
local function set_pending_goto(env, stm)
  local scope = env.scope
  get_logger().debug("Setting pending goto statement", {
    label = stm[1],
    scope = scope,
    position = stm.pos,
  })

  table.insert(env[scope]["goto"], stm)
  return true
end

--- Verifies that all pending `goto` statements registered during traversal have visible target labels.
---@param env table Validation environment.
---@return boolean|nil success `true` if all gotos are valid, `nil` if an invalid goto is found.
---@return string? error_message Error message if an invalid goto is found.
---@private
local function verify_pending_gotos(env)
  get_logger().debug("Verifying all pending goto statements", {
    max_scope = env.maxscope,
  })

  local goto_count = 0
  for s = env.maxscope, 0, -1 do
    goto_count = goto_count + #env[s]["goto"]
  end

  get_logger().debug("Found pending goto statements", {
    count = goto_count,
  })

  for s = env.maxscope, 0, -1 do
    for k, v in ipairs(env[s]["goto"]) do
      get_logger().debug("Checking goto statement", {
        label = v[1],
        scope = s,
        index = k,
      })

      if not exist_label(env, s, v) then
        local msg = "no visible label '%s' for <goto>"
        msg = string.format(msg, v[1])

        get_logger().error("No visible label for goto", {
          label = v[1],
          scope = s,
          position = v.pos,
        })

        return nil, syntaxerror(env.errorinfo, v.pos, msg)
      end
    end
  end

  get_logger().debug("All goto statements verified successfully")
  return true
end

--- Sets the vararg status (whether it accepts `...`) for the current function scope.
---@param env table Validation environment.
---@param is_vararg boolean `true` if the function is vararg, `false` otherwise.
---@return nil
---@private
local function set_vararg(env, is_vararg)
  env["function"][env.fscope].is_vararg = is_vararg
end

-- Forward declarations
local traverse_stm, traverse_exp, traverse_var
local traverse_block, traverse_explist, traverse_varlist, traverse_parlist

--- Traverses a function parameter list AST node. Sets vararg status.
---@param env table Validation environment.
---@param parlist table Parameter list AST node (array of `Id` or `Dots`).
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
function traverse_parlist(env, parlist)
  local len = #parlist
  local is_vararg = false
  if len > 0 and parlist[len].tag == "Dots" then
    is_vararg = true
  end
  set_vararg(env, is_vararg)
  return true
end

--- Traverses a function definition AST node (`Function`).
--- Creates new function and block scopes, traverses parameters and body.
---@param env table Validation environment.
---@param exp table Function AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_function(env, exp)
  scope_util.new_function(env)
  scope_util.new_scope(env)
  local status, msg = traverse_parlist(env, exp[1])
  if not status then
    return status, msg
  end
  status, msg = traverse_block(env, exp[2])
  if not status then
    return status, msg
  end
  scope_util.end_scope(env)
  scope_util.end_function(env)
  return true
end

--- Traverses an operation AST node (`Op`). Traverses operands recursively.
---@param env table Validation environment.
---@param exp table Operation AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_op(env, exp)
  local status, msg = traverse_exp(env, exp[2])
  if not status then
    return status, msg
  end
  if exp[3] then
    status, msg = traverse_exp(env, exp[3])
    if not status then
      return status, msg
    end
  end
  return true
end

--- Traverses a parenthesized expression AST node (`Paren`). Traverses the inner expression.
---@param env table Validation environment.
---@param exp table Paren AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_paren(env, exp)
  local status, msg = traverse_exp(env, exp[1])
  if not status then
    return status, msg
  end
  return true
end

--- Traverses a table constructor AST node (`Table`). Traverses fields/pairs recursively.
---@param env table Validation environment.
---@param fieldlist table Field list AST node (array of expressions or `Pair` nodes).
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_table(env, fieldlist)
  for k, v in ipairs(fieldlist) do
    local tag = v.tag
    if tag == "Pair" then
      local status, msg = traverse_exp(env, v[1])
      if not status then
        return status, msg
      end
      status, msg = traverse_exp(env, v[2])
      if not status then
        return status, msg
      end
    else
      local status, msg = traverse_exp(env, v)
      if not status then
        return status, msg
      end
    end
  end
  return true
end

--- Traverses a vararg expression AST node (`Dots`). Validates it's inside a vararg function.
---@param env table Validation environment.
---@param exp table Dots AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_vararg(env, exp)
  get_logger().debug("Traversing vararg expression", {
    position = exp.pos,
    function_scope = env.fscope,
  })

  if not env["function"][env.fscope].is_vararg then
    local msg = "cannot use '...' outside a vararg function"

    get_logger().error("Invalid vararg usage", {
      position = exp.pos,
      function_scope = env.fscope,
      is_vararg = false,
    })

    return nil, syntaxerror(env.errorinfo, exp.pos, msg)
  end

  get_logger().debug("Vararg expression is valid")
  return true
end

--- Traverses a function call AST node (`Call`). Traverses function expression and arguments.
---@param env table Validation environment.
---@param call table Call AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_call(env, call)
  local status, msg = traverse_exp(env, call[1])
  if not status then
    return status, msg
  end
  for i = 2, #call do
    status, msg = traverse_exp(env, call[i])
    if not status then
      return status, msg
    end
  end
  return true
end

--- Traverses a method invocation AST node (`Invoke`). Traverses object, method name, and arguments.
---@param env table Validation environment.
---@param invoke table Invoke AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_invoke(env, invoke)
  local status, msg = traverse_exp(env, invoke[1])
  if not status then
    return status, msg
  end
  for i = 3, #invoke do
    status, msg = traverse_exp(env, invoke[i])
    if not status then
      return status, msg
    end
  end
  return true
end

--- Traverses an assignment statement AST node (`Set`). Traverses variables and expressions.
---@param env table Validation environment.
---@param stm table Set AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_assignment(env, stm)
  local status, msg = traverse_varlist(env, stm[1])
  if not status then
    return status, msg
  end
  status, msg = traverse_explist(env, stm[2])
  if not status then
    return status, msg
  end
  return true
end

--- Traverses a break statement AST node (`Break`). Validates it's inside a loop.
---@param env table Validation environment.
---@param stm table Break AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_break(env, stm)
  get_logger().debug("Traversing break statement", {
    position = stm.pos,
    inside_loop = scope_util.insideloop(env),
    loop_count = env.loop,
  })

  if not scope_util.insideloop(env) then
    local msg = "<break> not inside a loop"

    get_logger().error("Invalid break statement", {
      position = stm.pos,
      inside_loop = false,
      loop_count = env.loop,
    })

    return nil, syntaxerror(env.errorinfo, stm.pos, msg)
  end

  get_logger().debug("Break statement is valid")
  return true
end

--- Traverses a generic for loop AST node (`Forin`). Creates scope/loop context, traverses expressions and block.
---@param env table Validation environment.
---@param stm table Forin AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_forin(env, stm)
  scope_util.begin_loop(env)
  scope_util.new_scope(env)
  local status, msg = traverse_explist(env, stm[2])
  if not status then
    return status, msg
  end
  status, msg = traverse_block(env, stm[3])
  if not status then
    return status, msg
  end
  scope_util.end_scope(env)
  scope_util.end_loop(env)
  return true
end

--- Traverses a numeric for loop AST node (`Fornum`). Creates scope/loop context, traverses expressions and block.
---@param env table Validation environment.
---@param stm table Fornum AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_fornum(env, stm)
  local status, msg
  scope_util.begin_loop(env)
  scope_util.new_scope(env)
  status, msg = traverse_exp(env, stm[2])
  if not status then
    return status, msg
  end
  status, msg = traverse_exp(env, stm[3])
  if not status then
    return status, msg
  end
  if stm[5] then
    status, msg = traverse_exp(env, stm[4])
    if not status then
      return status, msg
    end
    status, msg = traverse_block(env, stm[5])
    if not status then
      return status, msg
    end
  else
    status, msg = traverse_block(env, stm[4])
    if not status then
      return status, msg
    end
  end
  scope_util.end_scope(env)
  scope_util.end_loop(env)
  return true
end

--- Traverses a goto statement AST node (`Goto`). Registers it as pending verification.
---@param env table Validation environment.
---@param stm table Goto AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_goto(env, stm)
  local status, msg = set_pending_goto(env, stm)
  if not status then
    return status, msg
  end
  return true
end

--- Traverses an if/elseif/else statement AST node (`If`). Traverses condition expressions and blocks.
---@param env table Validation environment.
---@param stm table If AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_if(env, stm)
  local len = #stm
  if len % 2 == 0 then
    for i = 1, len, 2 do
      local status, msg = traverse_exp(env, stm[i])
      if not status then
        return status, msg
      end
      status, msg = traverse_block(env, stm[i + 1])
      if not status then
        return status, msg
      end
    end
  else
    for i = 1, len - 1, 2 do
      local status, msg = traverse_exp(env, stm[i])
      if not status then
        return status, msg
      end
      status, msg = traverse_block(env, stm[i + 1])
      if not status then
        return status, msg
      end
    end
    local status, msg = traverse_block(env, stm[len])
    if not status then
      return status, msg
    end
  end
  return true
end

--- Traverses a label definition AST node (`Label`). Registers the label in the current scope.
---@param env table Validation environment.
---@param stm table Label AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_label(env, stm)
  local status, msg = set_label(env, stm[1], stm.pos)
  if not status then
    return status, msg
  end
  return true
end

--- Traverses a local variable declaration AST node (`Local`). Traverses initialization expressions.
---@param env table Validation environment.
---@param stm table Local AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_let(env, stm)
  local status, msg = traverse_explist(env, stm[2])
  if not status then
    return status, msg
  end
  return true
end

--- Traverses a local function declaration AST node (`Localrec`). Traverses the function definition expression.
---@param env table Validation environment.
---@param stm table Localrec AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_letrec(env, stm)
  local status, msg = traverse_exp(env, stm[2][1])
  if not status then
    return status, msg
  end
  return true
end

--- Traverses a repeat-until loop AST node (`Repeat`). Creates loop context, traverses block and condition expression.
---@param env table Validation environment.
---@param stm table Repeat AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_repeat(env, stm)
  scope_util.begin_loop(env)
  local status, msg = traverse_block(env, stm[1])
  if not status then
    return status, msg
  end
  status, msg = traverse_exp(env, stm[2])
  if not status then
    return status, msg
  end
  scope_util.end_loop(env)
  return true
end

--- Traverses a return statement AST node (`Return`). Traverses return expressions.
---@param env table Validation environment.
---@param stm table Return AST node (array of expressions).
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_return(env, stm)
  local status, msg = traverse_explist(env, stm)
  if not status then
    return status, msg
  end
  return true
end

--- Traverses a while loop AST node (`While`). Creates loop context, traverses condition expression and block.
---@param env table Validation environment.
---@param stm table While AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
local function traverse_while(env, stm)
  scope_util.begin_loop(env)
  local status, msg = traverse_exp(env, stm[1])
  if not status then
    return status, msg
  end
  status, msg = traverse_block(env, stm[2])
  if not status then
    return status, msg
  end
  scope_util.end_loop(env)
  return true
end

--- Traverses a variable AST node (`Id` or `Index`).
---@param env table Validation environment.
---@param var table Variable AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
function traverse_var(env, var)
  local tag = var.tag
  if tag == "Id" then -- `Id{ <string> }
    return true
  elseif tag == "Index" then -- `Index{ expr expr }
    local status, msg = traverse_exp(env, var[1])
    if not status then
      return status, msg
    end
    status, msg = traverse_exp(env, var[2])
    if not status then
      return status, msg
    end
    return true
  else
    error("expecting a variable, but got a " .. tag)
  end
end

--- Traverses a list of variable AST nodes.
---@param env table Validation environment.
---@param varlist table Array of variable AST nodes.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
function traverse_varlist(env, varlist)
  for k, v in ipairs(varlist) do
    local status, msg = traverse_var(env, v)
    if not status then
      return status, msg
    end
  end
  return true
end

--- Traverses an expression AST node by dispatching to specific traversal functions based on `exp.tag`.
---@param env table Validation environment.
---@param exp table Expression AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
function traverse_exp(env, exp)
  local tag = exp.tag
  if
    tag == "Nil"
    or tag == "Boolean" -- `Boolean{ <boolean> }
    or tag == "Number" -- `Number{ <number> }
    or tag == "String"
  then -- `String{ <string> }
    return true
  elseif tag == "Dots" then
    return traverse_vararg(env, exp)
  elseif tag == "Function" then -- `Function{ { `Id{ <string> }* `Dots? } block }
    return traverse_function(env, exp)
  elseif tag == "Table" then -- `Table{ ( `Pair{ expr expr } | expr )* }
    return traverse_table(env, exp)
  elseif tag == "Op" then -- `Op{ opid expr expr? }
    return traverse_op(env, exp)
  elseif tag == "Paren" then -- `Paren{ expr }
    return traverse_paren(env, exp)
  elseif tag == "Call" then -- `Call{ expr expr* }
    return traverse_call(env, exp)
  elseif tag == "Invoke" then -- `Invoke{ expr `String{ <string> } expr* }
    return traverse_invoke(env, exp)
  elseif
    tag == "Id" -- `Id{ <string> }
    or tag == "Index"
  then -- `Index{ expr expr }
    return traverse_var(env, exp)
  else
    error("expecting an expression, but got a " .. tag)
  end
end

--- Traverses a list of expression AST nodes.
---@param env table Validation environment.
---@param explist table Array of expression AST nodes.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
function traverse_explist(env, explist)
  for k, v in ipairs(explist) do
    local status, msg = traverse_exp(env, v)
    if not status then
      return status, msg
    end
  end
  return true
end

--- Traverses a statement AST node by dispatching to specific traversal functions based on `stm.tag`.
---@param env table Validation environment.
---@param stm table Statement AST node.
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
function traverse_stm(env, stm)
  local tag = stm.tag
  if tag == "Do" then -- `Do{ stat* }
    return traverse_block(env, stm)
  elseif tag == "Set" then -- `Set{ {lhs+} {expr+} }
    return traverse_assignment(env, stm)
  elseif tag == "While" then -- `While{ expr block }
    return traverse_while(env, stm)
  elseif tag == "Repeat" then -- `Repeat{ block expr }
    return traverse_repeat(env, stm)
  elseif tag == "If" then -- `If{ (expr block)+ block? }
    return traverse_if(env, stm)
  elseif tag == "Fornum" then -- `Fornum{ ident expr expr expr? block }
    return traverse_fornum(env, stm)
  elseif tag == "Forin" then -- `Forin{ {ident+} {expr+} block }
    return traverse_forin(env, stm)
  elseif tag == "Local" then -- `Local{ {ident+} {expr+}? }
    return traverse_let(env, stm)
  elseif tag == "Localrec" then -- `Localrec{ ident expr }
    return traverse_letrec(env, stm)
  elseif tag == "Goto" then -- `Goto{ <string> }
    return traverse_goto(env, stm)
  elseif tag == "Label" then -- `Label{ <string> }
    return traverse_label(env, stm)
  elseif tag == "Return" then -- `Return{ <expr>* }
    return traverse_return(env, stm)
  elseif tag == "Break" then
    return traverse_break(env, stm)
  elseif tag == "Call" then -- `Call{ expr expr* }
    return traverse_call(env, stm)
  elseif tag == "Invoke" then -- `Invoke{ expr `String{ <string> } expr* }
    return traverse_invoke(env, stm)
  else
    error("expecting a statement, but got a " .. tag)
  end
end

--- Traverses a block AST node (array of statements). Creates a new scope.
---@param env table Validation environment.
---@param block table Block AST node (array of statement nodes).
---@return boolean|nil, string? `true, nil` on success, or `nil, error_message`.
---@private
function traverse_block(env, block)
  scope_util.new_scope(env)
  for k, v in ipairs(block) do
    local status, msg = traverse_stm(env, v)
    if not status then
      return status, msg
    end
  end
  scope_util.end_scope(env)
  return true
end

--- Validates the AST structure and semantics (breaks, gotos, varargs).
---@param ast table The AST block (array of statement nodes) to validate.
---@param errorinfo {subject: string, filename: string} Table containing source string and filename for error reporting.
---@return table|nil ast The input AST table if validation succeeds.
---@return string? error_message Error message string if validation fails.
function M.validate(ast, errorinfo)
  get_logger().debug("Starting AST validation")
  assert(type(ast) == "table")
  assert(type(errorinfo) == "table")

  local env = {
    errorinfo = errorinfo,
    ["function"] = {},
    scope = -1,
    maxscope = -1,
    fscope = -1,
    loop = 0,
  }

  get_logger().debug("Initialized validation environment", {
    has_errorinfo = errorinfo ~= nil,
    ast_type = type(ast),
  })

  scope_util.new_function(env)
  set_vararg(env, true)

  get_logger().debug("Starting block traversal")
  local status, msg = traverse_block(env, ast)
  if not status then
    get_logger().error("Block traversal failed", {
      error = msg,
    })
    return status, msg
  end

  scope_util.end_function(env)

  get_logger().debug("Verifying pending goto statements")
  status, msg = verify_pending_gotos(env)
  if not status then
    get_logger().error("Goto verification failed", {
      error = msg,
    })
    return status, msg
  end

  get_logger().debug("AST validation completed successfully")
  return ast
end

--- Helper function exported to format syntax error messages. Uses internal `syntaxerror` function.
---@param errorinfo {subject: string, filename: string} Table containing the source string and filename.
---@param pos number The character position (1-based) where the error occurred.
---@param msg string The specific error message detail.
---@return string The fully formatted error message string.
function M.syntaxerror(errorinfo, pos, msg)
  get_logger().error("Syntax error encountered", {
    filename = errorinfo and errorinfo.filename or "unknown",
    position = pos,
    message = msg,
  })
  return syntaxerror(errorinfo, pos, msg)
end

return M
