--- AST Pretty Printer
---
--- This module implements a pretty printer for the abstract syntax tree (AST)
--- generated by the parser. It converts the AST back into a human-readable
--- string representation (similar to Lua code, but focused on AST structure).
--- Based on lua-parser by Andre Murbach Maidl (https://github.com/andremm/lua-parser).
---
--- @module lib.tools.parser.pp
--- @author Andre Murbach Maidl (original), Firmo Team (adaptations)
--- @license MIT
--- @copyright 2023-2025 Firmo Team, Andre Murbach Maidl (original)
--- @version 1.0.0

---@class parser.pp The public API for the AST pretty-printer.
---@field _VERSION string Module version.
---@field tostring fun(ast: table, options?: {indent?: number, line_length?: number, colors?: boolean}): string Convert AST to formatted string representation.
---@field print fun(ast: table): nil Prints the AST string representation using `tostring` (via logger or io.write).
---@field dump fun(ast: table, indent?: number, use_logger?: boolean): string|nil Dumps the AST structure recursively. Returns string if `use_logger` is true, otherwise prints to io.write and returns nil.
---@field log_dump fun(ast: table): nil Logs the detailed AST dump using the get_logger().

local M = {}

--- Module version
M._VERSION = "1.0.0"

-- Lazy-load dependencies to avoid circular dependencies
---@diagnostic disable-next-line: unused-local
local _logging

-- Local helper for safe requires without dependency on error_handler
local function try_require(module_name)
  local success, result = pcall(require, module_name)
  if not success then
    print("Warning: Failed to load module:", module_name, "Error:", result)
    return nil
  end
  return result
end

--- Get the logging module with lazy loading to avoid circular dependencies
---@return table|nil The logging module or nil if not available
local function get_logging()
  if not _logging then
    _logging = try_require("lib.tools.logging")
  end
  return _logging
end

--- Get a logger instance for this module
---@return table A logger instance (either real or stub)
local function get_logger()
  local logging = get_logging()
  if logging then
    return logging.get_logger("parser.pp")
  end
  -- Return a stub logger if logging module isn't available
  return {
    error = function(msg)
      print("[ERROR] " .. msg)
    end,
    warn = function(msg)
      print("[WARN] " .. msg)
    end,
    info = function(msg)
      print("[INFO] " .. msg)
    end,
    debug = function(msg)
      print("[DEBUG] " .. msg)
    end,
    trace = function(msg)
      print("[TRACE] " .. msg)
    end,
  }
end

local block2str, stm2str, exp2str, var2str
local explist2str, varlist2str, parlist2str, fieldlist2str

--- Check if a byte value is a control character.
---@param x number Byte value.
---@return boolean `true` if control character, `false` otherwise.
---@private
local function iscntrl(x)
  if (x >= 0 and x <= 31) or (x == 127) then
    return true
  end
  return false
end

--- Check if a byte value represents a printable character (not a control character).
---@param x number Byte value.
---@return boolean `true` if printable, `false` otherwise.
---@private
local function isprint(x)
  return not iscntrl(x)
end

--- Escapes a string for safe display within the AST string representation.
--- Handles quotes, backslashes, and control characters.
---@param str string Input string.
---@return string Escaped string.
---@private
local function fixed_string(str)
  local new_str = ""
  for i = 1, string.len(str) do
    local char = string.byte(str, i)
    if char == 34 then
      new_str = new_str .. string.format('\\"')
    elseif char == 92 then
      new_str = new_str .. string.format("\\\\")
    elseif char == 7 then
      new_str = new_str .. string.format("\\a")
    elseif char == 8 then
      new_str = new_str .. string.format("\\b")
    elseif char == 12 then
      new_str = new_str .. string.format("\\f")
    elseif char == 10 then
      new_str = new_str .. string.format("\\n")
    elseif char == 13 then
      new_str = new_str .. string.format("\\r")
    elseif char == 9 then
      new_str = new_str .. string.format("\\t")
    elseif char == 11 then
      new_str = new_str .. string.format("\\v")
    else
      if isprint(char) then
        new_str = new_str .. string.format("%c", char)
      else
        new_str = new_str .. string.format("\\%03d", char)
      end
    end
  end
  return new_str
end

--- Formats an identifier name (string) for display (quoted).
---@param name string The identifier name.
---@return string Quoted string representation.
---@private
local function name2str(name)
  return string.format('"%s"', name)
end

--- Formats a boolean value for display ("true" or "false").
---@param b boolean The boolean value.
---@return string String representation ("true" or "false").
---@private
local function boolean2str(b)
  return string.format('"%s"', tostring(b))
end

--- Formats a number for display (as a string).
---@param n number The number.
---@return string String representation of the number.
---@private
local function number2str(n)
  return string.format('"%s"', tostring(n))
end

--- Formats a string literal for display (quoted and escaped).
---@param s string The string value.
---@return string Quoted and escaped string representation.
---@private
local function string2str(s)
  return string.format('"%s"', fixed_string(s))
end

--- Formats a variable AST node (`Id`, `Index`) to its string representation.
---@param var table AST node (expected tags: "Id", "Index").
---@return string Formatted string representation (e.g., "`Id \"name\"`", "`Index{ expr, expr }`").
---@private
---@throws error If `var.tag` is invalid for a variable node.
function var2str(var)
  local tag = var.tag
  local str = "`" .. tag
  if tag == "Id" then -- `Id{ <string> }
    str = str .. " " .. name2str(var[1])
  elseif tag == "Index" then -- `Index{ expr expr }
    str = str .. "{ "
    str = str .. exp2str(var[1]) .. ", "
    str = str .. exp2str(var[2])
    str = str .. " }"
  else
    error("expecting a variable, but got a " .. tag)
  end
  return str
end

--- Formats an array of variable AST nodes into a string representation.
---@param varlist table Array of variable AST nodes.
---@return string Formatted string (e.g., "{ `Id \"a\"`, `Id \"b\"` }").
---@private
function varlist2str(varlist)
  local l = {}
  for k, v in ipairs(varlist) do
    l[k] = var2str(v)
  end
  return "{ " .. table.concat(l, ", ") .. " }"
end

--- Formats a function parameter list AST node into a string representation.
--- Handles named parameters (`Id`) and varargs (`Dots`).
---@param parlist table AST node representing the parameter list (an array of `Id` or `Dots` nodes).
---@return string Formatted string (e.g., "{ `Id \"a\"`, `Id \"b\"`, `Dots` }").
---@private
function parlist2str(parlist)
  local l = {}
  local len = #parlist
  local is_vararg = false
  if len > 0 and parlist[len].tag == "Dots" then
    is_vararg = true
    len = len - 1
  end
  local i = 1
  while i <= len do
    l[i] = var2str(parlist[i])
    i = i + 1
  end
  if is_vararg then
    l[i] = "`" .. parlist[i].tag
  end
  return "{ " .. table.concat(l, ", ") .. " }"
end

--- Formats a table constructor field list AST node into a string representation.
--- Handles both key-value pairs (`Pair`) and simple value expressions.
---@param fieldlist table AST node representing the field list (an array of expression or `Pair` nodes).
---@return string Formatted string (e.g., "{ `Pair{ expr, expr }`, expr }"). Returns "" if list is empty.
---@private
function fieldlist2str(fieldlist)
  local l = {}
  for k, v in ipairs(fieldlist) do
    local tag = v.tag
    if tag == "Pair" then -- `Pair{ expr expr }
      l[k] = "`" .. tag .. "{ "
      l[k] = l[k] .. exp2str(v[1]) .. ", " .. exp2str(v[2])
      l[k] = l[k] .. " }"
    else -- expr
      l[k] = exp2str(v)
    end
  end
  if #l > 0 then
    return "{ " .. table.concat(l, ", ") .. " }"
  else
    return ""
  end
end

--- Formats an expression AST node to its string representation.
--- Handles various expression types (literals, variables, function defs, tables, operations, calls, etc.).
---@param exp table AST node representing an expression.
---@return string Formatted string representation of the expression.
---@private
---@throws error If `exp.tag` represents an invalid or unexpected expression type.
function exp2str(exp)
  local tag = exp.tag
  local str = "`" .. tag
  if tag == "Nil" or tag == "Dots" then
  elseif tag == "Boolean" then -- `Boolean{ <boolean> }
    str = str .. " " .. boolean2str(exp[1])
  elseif tag == "Number" then -- `Number{ <number> }
    str = str .. " " .. number2str(exp[1])
  elseif tag == "String" then -- `String{ <string> }
    str = str .. " " .. string2str(exp[1])
  elseif tag == "Function" then -- `Function{ { `Id{ <string> }* `Dots? } block }
    str = str .. "{ "
    str = str .. parlist2str(exp[1]) .. ", "
    str = str .. block2str(exp[2])
    str = str .. " }"
  elseif tag == "Table" then -- `Table{ ( `Pair{ expr expr } | expr )* }
    str = str .. fieldlist2str(exp)
  elseif tag == "Op" then -- `Op{ opid expr expr? }
    str = str .. "{ "
    str = str .. name2str(exp[1]) .. ", "
    str = str .. exp2str(exp[2])
    if exp[3] then
      str = str .. ", " .. exp2str(exp[3])
    end
    str = str .. " }"
  elseif tag == "Paren" then -- `Paren{ expr }
    str = str .. "{ " .. exp2str(exp[1]) .. " }"
  elseif tag == "Call" then -- `Call{ expr expr* }
    str = str .. "{ "
    str = str .. exp2str(exp[1])
    if exp[2] then
      for i = 2, #exp do
        str = str .. ", " .. exp2str(exp[i])
      end
    end
    str = str .. " }"
  elseif tag == "Invoke" then -- `Invoke{ expr `String{ <string> } expr* }
    str = str .. "{ "
    str = str .. exp2str(exp[1]) .. ", "
    str = str .. exp2str(exp[2])
    if exp[3] then
      for i = 3, #exp do
        str = str .. ", " .. exp2str(exp[i])
      end
    end
    str = str .. " }"
  elseif
    tag == "Id" -- `Id{ <string> }
    or tag == "Index"
  then -- `Index{ expr expr }
    str = var2str(exp)
  else
    error("expecting an expression, but got a " .. tag)
  end
  return str
end

--- Formats an array of expression AST nodes into a string representation.
---@param explist table Array of expression AST nodes.
---@return string Formatted string (e.g., "{ expr, expr }"). Returns "" if list is empty.
---@private
function explist2str(explist)
  local l = {}
  for k, v in ipairs(explist) do
    l[k] = exp2str(v)
  end
  if #l > 0 then
    return "{ " .. table.concat(l, ", ") .. " }"
  else
    return ""
  end
end

--- Formats a statement AST node to its string representation.
--- Handles various statement types (assignments, loops, conditionals, function calls, etc.).
---@param stm table AST node representing a statement.
---@return string Formatted string representation of the statement.
---@private
---@throws error If `stm.tag` represents an invalid or unexpected statement type.
function stm2str(stm)
  local tag = stm.tag
  local str = "`" .. tag
  if tag == "Do" then -- `Do{ stat* }
    local l = {}
    for k, v in ipairs(stm) do
      l[k] = stm2str(v)
    end
    str = str .. "{ " .. table.concat(l, ", ") .. " }"
  elseif tag == "Set" then -- `Set{ {lhs+} {expr+} }
    str = str .. "{ "
    str = str .. varlist2str(stm[1]) .. ", "
    str = str .. explist2str(stm[2])
    str = str .. " }"
  elseif tag == "While" then -- `While{ expr block }
    str = str .. "{ "
    str = str .. exp2str(stm[1]) .. ", "
    str = str .. block2str(stm[2])
    str = str .. " }"
  elseif tag == "Repeat" then -- `Repeat{ block expr }
    str = str .. "{ "
    str = str .. block2str(stm[1]) .. ", "
    str = str .. exp2str(stm[2])
    str = str .. " }"
  elseif tag == "If" then -- `If{ (expr block)+ block? }
    str = str .. "{ "
    local len = #stm
    if len % 2 == 0 then
      local l = {}
      for i = 1, len - 2, 2 do
        str = str .. exp2str(stm[i]) .. ", " .. block2str(stm[i + 1]) .. ", "
      end
      str = str .. exp2str(stm[len - 1]) .. ", " .. block2str(stm[len])
    else
      local l = {}
      for i = 1, len - 3, 2 do
        str = str .. exp2str(stm[i]) .. ", " .. block2str(stm[i + 1]) .. ", "
      end
      str = str .. exp2str(stm[len - 2]) .. ", " .. block2str(stm[len - 1]) .. ", "
      str = str .. block2str(stm[len])
    end
    str = str .. " }"
  elseif tag == "Fornum" then -- `Fornum{ ident expr expr expr? block }
    str = str .. "{ "
    str = str .. var2str(stm[1]) .. ", "
    str = str .. exp2str(stm[2]) .. ", "
    str = str .. exp2str(stm[3]) .. ", "
    if stm[5] then
      str = str .. exp2str(stm[4]) .. ", "
      str = str .. block2str(stm[5])
    else
      str = str .. block2str(stm[4])
    end
    str = str .. " }"
  elseif tag == "Forin" then -- `Forin{ {ident+} {expr+} block }
    str = str .. "{ "
    str = str .. varlist2str(stm[1]) .. ", "
    str = str .. explist2str(stm[2]) .. ", "
    str = str .. block2str(stm[3])
    str = str .. " }"
  elseif tag == "Local" then -- `Local{ {ident+} {expr+}? }
    str = str .. "{ "
    str = str .. varlist2str(stm[1])
    if #stm[2] > 0 then
      str = str .. ", " .. explist2str(stm[2])
    else
      str = str .. ", " .. "{  }"
    end
    str = str .. " }"
  elseif tag == "Localrec" then -- `Localrec{ ident expr }
    str = str .. "{ "
    str = str .. "{ " .. var2str(stm[1][1]) .. " }, "
    str = str .. "{ " .. exp2str(stm[2][1]) .. " }"
    str = str .. " }"
  elseif
    tag == "Goto" -- `Goto{ <string> }
    or tag == "Label"
  then -- `Label{ <string> }
    str = str .. "{ " .. name2str(stm[1]) .. " }"
  elseif tag == "Return" then -- `Return{ <expr>* }
    str = str .. explist2str(stm)
  elseif tag == "Break" then
  elseif tag == "Call" then -- `Call{ expr expr* }
    str = str .. "{ "
    str = str .. exp2str(stm[1])
    if stm[2] then
      for i = 2, #stm do
        str = str .. ", " .. exp2str(stm[i])
      end
    end
    str = str .. " }"
  elseif tag == "Invoke" then -- `Invoke{ expr `String{ <string> } expr* }
    str = str .. "{ "
    str = str .. exp2str(stm[1]) .. ", "
    str = str .. exp2str(stm[2])
    if stm[3] then
      for i = 3, #stm do
        str = str .. ", " .. exp2str(stm[i])
      end
    end
    str = str .. " }"
  else
    error("expecting a statement, but got a " .. tag)
  end
  return str
end

--- Formats a block (array of statements) AST node to its string representation.
---@param block table AST node representing a block (an array of statement nodes).
---@return string Formatted string representation of the block (e.g., "{ stat, stat }").
---@private
function block2str(block)
  local l = {}
  for k, v in ipairs(block) do
    l[k] = stm2str(v)
  end
  return "{ " .. table.concat(l, ", ") .. " }"
end

--- Converts an AST block (array of statements) to its string representation.
---@param t table The AST block (array of statement nodes).
---@return string The string representation of the AST. Returns "invalid AST" if input is not a table.
function M.tostring(t)
  assert(type(t) == "table")
  return block2str(t)
end

--- Prints the AST string representation (from `M.tostring`) using the logger if available,
--- otherwise uses `io.write`.
---@param t table The AST block to print.
---@return nil
function M.print(t)
  assert(type(t) == "table")

  get_logger().debug("AST structure", { ast_string = M.tostring(t) })
end

--- Recursively dumps the structure of an AST table with indentation.
--- Can either print directly to `io.write` or return the formatted string for logging.
---@param t table The AST node or block to dump.
---@param i? number Current indentation level (default 0).
---@param use_logger? boolean If true, returns the dump string instead of printing it.
---@return string|nil dump_string The formatted dump string if `use_logger` is true, otherwise `nil`.
function M.dump(t, i, use_logger)
  i = i or 0
  use_logger = use_logger or false

  local log_str = ""
  local function append(str)
    if use_logger then
      log_str = log_str .. str
    else
      io.write(str)
    end
  end

  append(string.format("{\n"))
  append(string.format("%s[tag] = %s\n", string.rep(" ", i + 2), t.tag or "nil"))
  append(string.format("%s[pos] = %s\n", string.rep(" ", i + 2), t.pos or "nil"))

  for k, v in ipairs(t) do
    append(string.format("%s[%s] = ", string.rep(" ", i + 2), tostring(k)))
    if type(v) == "table" then
      if use_logger then
        log_str = log_str .. M.dump(v, i + 2, true)
      else
        M.dump(v, i + 2)
      end
    else
      append(string.format("%s\n", tostring(v)))
    end
  end

  append(string.format("%s}\n", string.rep(" ", i)))

  if use_logger then
    return log_str
  end
end

--- Dumps the detailed AST structure using the logger (at DEBUG level) if available,
--- otherwise prints using `M.dump`.
---@param t table The AST node or block to dump.
---@return nil
function M.log_dump(t)
  get_logger().debug("AST detailed dump", { ast_dump = M.dump(t, 0, true) })
end

return M
